package com.chat4all.message.api;

import com.chat4all.message.api.dto.SendMessageRequest;
import com.chat4all.message.api.dto.SendMessageResponse;
import com.chat4all.message.domain.Message;
import com.chat4all.message.service.MessageService;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.time.Instant;

/**
 * Reactive REST Controller for message operations
 * 
 * Endpoints:
 * - POST /messages - Accept a new message for processing (returns HTTP 202)
 * - GET /messages/{id}/status - Get message delivery status
 * 
 * Security: Protected by API Gateway OAuth2 (scope: messages:write)
 * 
 * Metrics (T112):
 * - messages.inbound.total: Counter for incoming messages (tagged by channel)
 * 
 * @author Chat4All Team
 * @version 1.0.0
 */
@Slf4j
@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
@Tag(name = "Messages", description = "Message sending and status tracking endpoints")
public class MessageController {

    private final MessageService messageService;
    private final MeterRegistry meterRegistry;

    /**
     * Accepts a new message for processing (reactive).
     * 
     * Endpoint: POST /api/messages
     * Response: HTTP 202 Accepted (async processing)
     * 
     * Flow:
     * 1. Validate request (via @Valid)
     * 2. Increment inbound message counter (metrics)
     * 3. Convert DTO to Message entity
     * 4. Call MessageService.acceptMessage()
     * 5. Return 202 with message ID and status URL
     * 
     * The message is persisted to MongoDB and published to Kafka.
     * Actual delivery happens asynchronously via Router Service.
     * 
     * @param request SendMessageRequest validated request
     * @return Mono<ResponseEntity<SendMessageResponse>> with HTTP 202 and message details
     */
    @PostMapping
    @Operation(
        summary = "Send a new message",
        description = "Accepts a message for asynchronous delivery to external platforms (WhatsApp, Telegram, Instagram). Returns HTTP 202 with message ID for status tracking."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "202",
            description = "Message accepted for processing",
            content = @Content(schema = @Schema(implementation = SendMessageResponse.class))
        ),
        @ApiResponse(
            responseCode = "400",
            description = "Invalid request (missing required fields, invalid channel, content too long)"
        ),
        @ApiResponse(
            responseCode = "409",
            description = "Duplicate message (messageId already exists)"
        ),
        @ApiResponse(
            responseCode = "500",
            description = "Internal server error"
        )
    })
    public Mono<ResponseEntity<SendMessageResponse>> sendMessage(
        @Parameter(description = "Message to send", required = true)
        @Valid @RequestBody SendMessageRequest request) {
        log.info("Received message send request: conversationId={}, senderId={}, channel={}",
            request.getConversationId(), request.getSenderId(), request.getChannel());

        // Metric: Count inbound messages by channel (T112)
        Counter.builder("messages.inbound.total")
            .tag("channel", request.getChannel() != null ? request.getChannel().name() : "UNKNOWN")
            .description("Total number of inbound messages received")
            .register(meterRegistry)
            .increment();

        // Convert DTO to Message entity
        Message message = Message.builder()
            .messageId(request.getMessageId()) // May be null, will be generated by service
            .conversationId(request.getConversationId())
            .senderId(request.getSenderId())
            .recipientIds(request.getRecipientIds())
            .content(request.getContent())
            .contentType(request.getContentType())
            .fileId(request.getFileId()) // Deprecated - kept for backward compatibility
            .fileIds(request.getFileIds()) // New: supports multiple file attachments (T072)
            .channel(request.getChannel())
            .timestamp(Instant.now())
            .build();

        // Accept message (persist + publish)
        return messageService.acceptMessage(message)
            .map(savedMessage -> {
                // Build response
                SendMessageResponse response = SendMessageResponse.builder()
                    .messageId(savedMessage.getMessageId())
                    .conversationId(savedMessage.getConversationId())
                    .status(savedMessage.getStatus())
                    .acceptedAt(savedMessage.getCreatedAt())
                    .statusUrl("/api/messages/" + savedMessage.getMessageId() + "/status")
                    .build();

                log.info("Message accepted: messageId={}, status={}", savedMessage.getMessageId(), savedMessage.getStatus());

                // Return HTTP 202 Accepted
                return ResponseEntity.status(HttpStatus.ACCEPTED).body(response);
            });
    }

    /**
     * Retrieves the current status of a message (reactive).
     * 
     * Endpoint: GET /api/messages/{id}/status
     * Response: HTTP 200 OK with message details
     * 
     * Allows clients to poll for message delivery status.
     * For real-time updates, clients should use WebSocket endpoint (T053).
     * 
     * @param messageId Message identifier
     * @return Mono<ResponseEntity<Message>> with message details or 404 if not found
     */
    @GetMapping("/{messageId}/status")
    public Mono<ResponseEntity<Message>> getMessageStatus(@PathVariable String messageId) {
        log.debug("Fetching status for message: {}", messageId);

        return messageService.getMessageById(messageId)
            .map(message -> {
                log.debug("Message status: messageId={}, status={}", messageId, message.getStatus());
                return ResponseEntity.ok(message);
            })
            .defaultIfEmpty(ResponseEntity.notFound().build())
            .doOnSuccess(response -> {
                if (response.getStatusCode().value() == 404) {
                    log.warn("Message not found: {}", messageId);
                }
            });
    }

    /**
     * Exception handler for duplicate message errors.
     * 
     * Returns HTTP 409 Conflict when idempotency check detects a duplicate.
     * 
     * @param ex IllegalStateException with duplicate message details
     * @return ResponseEntity with HTTP 409 and error message
     */
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateMessage(IllegalStateException ex) {
        log.warn("Duplicate message request: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.builder()
            .error("Duplicate Message")
            .message(ex.getMessage())
            .timestamp(Instant.now())
            .build();

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    /**
     * Error response DTO for exception handling
     */
    @lombok.Data
    @lombok.Builder
    @lombok.NoArgsConstructor
    @lombok.AllArgsConstructor
    private static class ErrorResponse {
        private String error;
        private String message;
        private Instant timestamp;
    }
}
