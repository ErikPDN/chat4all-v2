package com.chat4all.message.api;

import com.chat4all.message.api.dto.SendMessageRequest;
import com.chat4all.message.api.dto.SendMessageResponse;
import com.chat4all.message.domain.Message;
import com.chat4all.message.service.MessageService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.time.Instant;

/**
 * Reactive REST Controller for message operations
 * 
 * Endpoints:
 * - POST /messages - Accept a new message for processing (returns HTTP 202)
 * - GET /messages/{id}/status - Get message delivery status
 * 
 * Security: Protected by API Gateway OAuth2 (scope: messages:write)
 * 
 * @author Chat4All Team
 * @version 1.0.0
 */
@Slf4j
@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
public class MessageController {

    private final MessageService messageService;

    /**
     * Accepts a new message for processing (reactive).
     * 
     * Endpoint: POST /api/messages
     * Response: HTTP 202 Accepted (async processing)
     * 
     * Flow:
     * 1. Validate request (via @Valid)
     * 2. Convert DTO to Message entity
     * 3. Call MessageService.acceptMessage()
     * 4. Return 202 with message ID and status URL
     * 
     * The message is persisted to MongoDB and published to Kafka.
     * Actual delivery happens asynchronously via Router Service.
     * 
     * @param request SendMessageRequest validated request
     * @return Mono<ResponseEntity<SendMessageResponse>> with HTTP 202 and message details
     */
    @PostMapping
    public Mono<ResponseEntity<SendMessageResponse>> sendMessage(@Valid @RequestBody SendMessageRequest request) {
        log.info("Received message send request: conversationId={}, senderId={}, channel={}",
            request.getConversationId(), request.getSenderId(), request.getChannel());

        // Convert DTO to Message entity
        Message message = Message.builder()
            .messageId(request.getMessageId()) // May be null, will be generated by service
            .conversationId(request.getConversationId())
            .senderId(request.getSenderId())
            .recipientIds(request.getRecipientIds())
            .content(request.getContent())
            .contentType(request.getContentType())
            .fileId(request.getFileId())
            .channel(request.getChannel())
            .timestamp(Instant.now())
            .build();

        // Accept message (persist + publish)
        return messageService.acceptMessage(message)
            .map(savedMessage -> {
                // Build response
                SendMessageResponse response = SendMessageResponse.builder()
                    .messageId(savedMessage.getMessageId())
                    .conversationId(savedMessage.getConversationId())
                    .status(savedMessage.getStatus())
                    .acceptedAt(savedMessage.getCreatedAt())
                    .statusUrl("/api/messages/" + savedMessage.getMessageId() + "/status")
                    .build();

                log.info("Message accepted: messageId={}, status={}", savedMessage.getMessageId(), savedMessage.getStatus());

                // Return HTTP 202 Accepted
                return ResponseEntity.status(HttpStatus.ACCEPTED).body(response);
            });
    }

    /**
     * Retrieves the current status of a message (reactive).
     * 
     * Endpoint: GET /api/messages/{id}/status
     * Response: HTTP 200 OK with message details
     * 
     * Allows clients to poll for message delivery status.
     * For real-time updates, clients should use WebSocket endpoint (T053).
     * 
     * @param messageId Message identifier
     * @return Mono<ResponseEntity<Message>> with message details or 404 if not found
     */
    @GetMapping("/{messageId}/status")
    public Mono<ResponseEntity<Message>> getMessageStatus(@PathVariable String messageId) {
        log.debug("Fetching status for message: {}", messageId);

        return messageService.getMessageById(messageId)
            .map(message -> {
                log.debug("Message status: messageId={}, status={}", messageId, message.getStatus());
                return ResponseEntity.ok(message);
            })
            .defaultIfEmpty(ResponseEntity.notFound().build())
            .doOnSuccess(response -> {
                if (response.getStatusCode().value() == 404) {
                    log.warn("Message not found: {}", messageId);
                }
            });
    }

    /**
     * Exception handler for duplicate message errors.
     * 
     * Returns HTTP 409 Conflict when idempotency check detects a duplicate.
     * 
     * @param ex IllegalStateException with duplicate message details
     * @return ResponseEntity with HTTP 409 and error message
     */
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateMessage(IllegalStateException ex) {
        log.warn("Duplicate message request: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.builder()
            .error("Duplicate Message")
            .message(ex.getMessage())
            .timestamp(Instant.now())
            .build();

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    /**
     * Error response DTO for exception handling
     */
    @lombok.Data
    @lombok.Builder
    @lombok.NoArgsConstructor
    @lombok.AllArgsConstructor
    private static class ErrorResponse {
        private String error;
        private String message;
        private Instant timestamp;
    }
}
